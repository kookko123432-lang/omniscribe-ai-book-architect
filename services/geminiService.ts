import { GoogleGenAI, Type, Schema } from "@google/genai";
import { BookSettings, ResearchData, BookStructure, Chapter } from "../types";

// Lazy initialization to prevent crash if process.env is not ready immediately
const getAiClient = () => {
  const apiKey = process.env.API_KEY;
  if (!apiKey) {
    console.error("API_KEY is missing from process.env");
    // We don't throw here to allow the UI to render, but API calls will fail.
  }
  return new GoogleGenAI({ apiKey: apiKey || '' });
};

const MODEL_REASONING = 'gemini-3-pro-preview';
const MODEL_WRITING = 'gemini-3-pro-preview';
const MODEL_IMAGE = 'gemini-2.5-flash-image';

/**
 * Helper: Clean JSON string from Markdown code blocks
 */
const cleanJson = (text: string): string => {
  if (!text) return "{}";
  let clean = text.trim();
  // Remove ```json ... ``` or ``` ... ``` wrappers
  if (clean.startsWith('```')) {
    clean = clean.replace(/^```(?:json)?/, '').replace(/```$/, '');
  }
  return clean.trim();
};

/**
 * AI Autofill: Generates book settings based on a simple topic
 */
export const autofillBookSettings = async (topicInput: string): Promise<Partial<BookSettings>> => {
  const prompt = `
    User wants to write a book about: "${topicInput || "A trending, best-selling topic"}"
    
    Act as a creative editor. Generate a compelling premise and setup for this book.
    Return a JSON object with:
    - title: A catchy title.
    - topic: A detailed paragraph expanding on the user's input.
    - targetAudience: Specific demographics.
    - toneAndStyle: Suggest a fitting tone.
    - mustInclude: 3-5 key elements or plot points that would make this book successful.
    - bookType: Guess the best fit type ('novel', 'non-fiction', 'textbook', 'biography', 'anthology').
  `;

  const schema: Schema = {
    type: Type.OBJECT,
    properties: {
      title: { type: Type.STRING },
      topic: { type: Type.STRING },
      targetAudience: { type: Type.STRING },
      toneAndStyle: { type: Type.STRING },
      mustInclude: { type: Type.STRING },
      bookType: { type: Type.STRING },
    },
    required: ["title", "topic", "targetAudience", "toneAndStyle", "mustInclude", "bookType"],
  };

  const ai = getAiClient();
  const response = await ai.models.generateContent({
    model: MODEL_REASONING,
    contents: prompt,
    config: {
      responseMimeType: "application/json",
      responseSchema: schema,
    }
  });

  const text = response.text;
  if (!text) throw new Error("Autofill failed");
  
  try {
    return JSON.parse(cleanJson(text));
  } catch (e) {
    console.error("Failed to parse autofill JSON:", text);
    throw new Error("Invalid response format");
  }
};

/**
 * Step 1: Deep Research
 */
export const performDeepResearch = async (topic: string, specificFocus: string, language: string): Promise<ResearchData> => {
  try {
    const prompt = `
      Perform deep research on the topic: "${topic}".
      Specific focus areas: ${specificFocus}.
      Target Language for Output: ${language}
      
      I am writing a comprehensive book. 
      Search for key facts, recent developments, historical context, and conflicting viewpoints if applicable.
      Synthesize the information into a detailed summary in ${language} that can be used as a knowledge base for writing.
      
      Return a summary of findings in ${language}.
    `;

    const ai = getAiClient();
    const response = await ai.models.generateContent({
      model: MODEL_REASONING,
      contents: prompt,
      config: {
        tools: [{ googleSearch: {} }],
      },
    });

    // Ensure findings is always a string, even if empty
    const findings = response.text || "No research findings generated by the model.";
    
    const sourceUrls: string[] = [];
    const chunks = response.candidates?.[0]?.groundingMetadata?.groundingChunks;
    if (chunks) {
      chunks.forEach((chunk: any) => {
        if (chunk.web?.uri) {
          sourceUrls.push(chunk.web.uri);
        }
      });
    }

    return {
      query: topic,
      findings,
      sourceUrls: Array.from(new Set(sourceUrls)),
    };
  } catch (error) {
    console.error("Research Error:", error);
    throw new Error("Failed to perform research. Please try again.");
  }
};

/**
 * Step 2: Outline Generation
 */
export const generateBookOutline = async (settings: BookSettings, research: ResearchData[]): Promise<BookStructure> => {
  const researchContext = research.map(r => `Research on ${r.query}:\n${r.findings}`).join("\n\n");

  const prompt = `
    You are a professional book architect.
    Design a comprehensive book structure for a book titled "${settings.title}".
    
    Type: ${settings.bookType}
    Language: ${settings.language} (The outline titles and descriptions MUST be in ${settings.language})
    Topic: ${settings.topic}
    Target Audience: ${settings.targetAudience}
    Tone: ${settings.toneAndStyle}
    Key Elements to Include: ${settings.mustInclude}
    Target Length Strategy: The user wants a very long book (100k+ words logic). 
    
    Break the book down into Chapters.
    CRITICAL: Break each Chapter down into detailed "Sections".
    Each Section represents a writing task of approximately 1000-2000 words.
    
    Context from Research:
    ${researchContext.substring(0, 20000)}
    
    Output JSON format only.
  `;

  const schema: Schema = {
    type: Type.OBJECT,
    properties: {
      chapters: {
        type: Type.ARRAY,
        items: {
          type: Type.OBJECT,
          properties: {
            title: { type: Type.STRING },
            sections: {
              type: Type.ARRAY,
              items: {
                type: Type.OBJECT,
                properties: {
                  title: { type: Type.STRING },
                  description: { type: Type.STRING, description: "Detailed instructions for the writer AI on what to cover in this specific section." }
                },
                required: ["title", "description"]
              }
            }
          },
          required: ["title", "sections"]
        }
      }
    },
    required: ["chapters"]
  };

  const ai = getAiClient();
  const response = await ai.models.generateContent({
    model: MODEL_REASONING,
    contents: prompt,
    config: {
      responseMimeType: "application/json",
      responseSchema: schema,
    }
  });

  const jsonText = response.text;
  if (!jsonText) throw new Error("Failed to generate outline.");

  try {
    const parsed = JSON.parse(cleanJson(jsonText));
    
    const chapters: Chapter[] = parsed.chapters.map((chap: any, cIdx: number) => ({
      id: `c-${cIdx}`,
      title: chap.title,
      sections: chap.sections.map((sec: any, sIdx: number) => ({
        id: `c-${cIdx}-s-${sIdx}`,
        title: sec.title,
        description: sec.description,
        status: 'pending',
        wordCount: 0,
      }))
    }));

    return { chapters };
  } catch (e) {
    console.error("Failed to parse outline JSON:", jsonText);
    throw new Error("Outline generation failed due to format error.");
  }
};

/**
 * Step 3: Section Writing
 */
export const writeSectionContent = async (
  sectionTitle: string,
  sectionDescription: string,
  bookSettings: BookSettings,
  chapterTitle: string,
  previousContentSummary: string,
  researchData: ResearchData[]
): Promise<string> => {
  
  const researchContext = researchData.map(r => r.findings).join("\n\n").substring(0, 10000);

  const prompt = `
    Role: You are the author writing a specific section of the book "${bookSettings.title}".
    
    Language: Write strictly in ${bookSettings.language}.
    Book Type: ${bookSettings.bookType}
    Current Chapter: ${chapterTitle}
    Current Section: ${sectionTitle}
    
    Specific Instructions for this Section:
    ${sectionDescription}
    
    Tone & Style: ${bookSettings.toneAndStyle}
    Target Audience: ${bookSettings.targetAudience}
    
    Story/Content Context (Summary of what came before):
    ${previousContentSummary}
    
    Research Context:
    ${researchContext}
    
    Task: Write the full content for this section. 
    Aim for depth, detail, and high quality. 
    Write in Markdown format.
    Do not output the title again, just the body content.
    Target word count for this section: 1500+ words if possible, be exhaustive.
  `;

  const ai = getAiClient();
  const response = await ai.models.generateContent({
    model: MODEL_WRITING,
    contents: prompt,
    config: {
    }
  });

  return response.text || "";
};

/**
 * Helper: Generate a summary
 */
export const summarizeContext = async (text: string): Promise<string> => {
  const prompt = `Summarize the following text in 3-4 sentences to serve as context for the continuation of the book. Capture key plot points or arguments established. Text: ${text.substring(0, 20000)}`;
  
  const ai = getAiClient();
  const response = await ai.models.generateContent({
    model: 'gemini-3-flash-preview', 
    contents: prompt,
  });
  
  return response.text || "";
}

/**
 * Step 4: Cover Generation
 */
export const generateBookCover = async (prompt: string): Promise<string> => {
  const ai = getAiClient();
  
  // Using gemini-2.5-flash-image for standard image generation
  const response = await ai.models.generateContent({
    model: MODEL_IMAGE,
    contents: {
      parts: [
        { text: prompt }
      ]
    },
    config: {
      imageConfig: {
        aspectRatio: "3:4", // Standard book cover ratio
      }
    }
  });

  // Extract base64 image
  for (const part of response.candidates?.[0]?.content?.parts || []) {
    if (part.inlineData) {
      return `data:image/png;base64,${part.inlineData.data}`;
    }
  }

  throw new Error("No image data returned");
};
